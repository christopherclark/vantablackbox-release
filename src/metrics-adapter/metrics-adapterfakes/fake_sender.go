// Code generated by counterfeiter. DO NOT EDIT.
package metricsadapterfakes

import (
	"sync"

	"github.com/wavefronthq/wavefront-sdk-go/event"
	"github.com/wavefronthq/wavefront-sdk-go/histogram"
	"github.com/wavefronthq/wavefront-sdk-go/senders"
)

type FakeSender struct {
	CloseStub        func()
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	FlushStub        func() error
	flushMutex       sync.RWMutex
	flushArgsForCall []struct {
	}
	flushReturns struct {
		result1 error
	}
	flushReturnsOnCall map[int]struct {
		result1 error
	}
	GetFailureCountStub        func() int64
	getFailureCountMutex       sync.RWMutex
	getFailureCountArgsForCall []struct {
	}
	getFailureCountReturns struct {
		result1 int64
	}
	getFailureCountReturnsOnCall map[int]struct {
		result1 int64
	}
	SendDeltaCounterStub        func(string, float64, string, map[string]string) error
	sendDeltaCounterMutex       sync.RWMutex
	sendDeltaCounterArgsForCall []struct {
		arg1 string
		arg2 float64
		arg3 string
		arg4 map[string]string
	}
	sendDeltaCounterReturns struct {
		result1 error
	}
	sendDeltaCounterReturnsOnCall map[int]struct {
		result1 error
	}
	SendDistributionStub        func(string, []histogram.Centroid, map[histogram.Granularity]bool, int64, string, map[string]string) error
	sendDistributionMutex       sync.RWMutex
	sendDistributionArgsForCall []struct {
		arg1 string
		arg2 []histogram.Centroid
		arg3 map[histogram.Granularity]bool
		arg4 int64
		arg5 string
		arg6 map[string]string
	}
	sendDistributionReturns struct {
		result1 error
	}
	sendDistributionReturnsOnCall map[int]struct {
		result1 error
	}
	SendEventStub        func(string, int64, int64, string, map[string]string, ...event.Option) error
	sendEventMutex       sync.RWMutex
	sendEventArgsForCall []struct {
		arg1 string
		arg2 int64
		arg3 int64
		arg4 string
		arg5 map[string]string
		arg6 []event.Option
	}
	sendEventReturns struct {
		result1 error
	}
	sendEventReturnsOnCall map[int]struct {
		result1 error
	}
	SendMetricStub        func(string, float64, int64, string, map[string]string) error
	sendMetricMutex       sync.RWMutex
	sendMetricArgsForCall []struct {
		arg1 string
		arg2 float64
		arg3 int64
		arg4 string
		arg5 map[string]string
	}
	sendMetricReturns struct {
		result1 error
	}
	sendMetricReturnsOnCall map[int]struct {
		result1 error
	}
	SendSpanStub        func(string, int64, int64, string, string, string, []string, []string, []senders.SpanTag, []senders.SpanLog) error
	sendSpanMutex       sync.RWMutex
	sendSpanArgsForCall []struct {
		arg1  string
		arg2  int64
		arg3  int64
		arg4  string
		arg5  string
		arg6  string
		arg7  []string
		arg8  []string
		arg9  []senders.SpanTag
		arg10 []senders.SpanLog
	}
	sendSpanReturns struct {
		result1 error
	}
	sendSpanReturnsOnCall map[int]struct {
		result1 error
	}
	StartStub        func()
	startMutex       sync.RWMutex
	startArgsForCall []struct {
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSender) Close() {
	fake.closeMutex.Lock()
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if fake.CloseStub != nil {
		fake.CloseStub()
	}
}

func (fake *FakeSender) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeSender) CloseCalls(stub func()) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeSender) Flush() error {
	fake.flushMutex.Lock()
	ret, specificReturn := fake.flushReturnsOnCall[len(fake.flushArgsForCall)]
	fake.flushArgsForCall = append(fake.flushArgsForCall, struct {
	}{})
	fake.recordInvocation("Flush", []interface{}{})
	fake.flushMutex.Unlock()
	if fake.FlushStub != nil {
		return fake.FlushStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.flushReturns
	return fakeReturns.result1
}

func (fake *FakeSender) FlushCallCount() int {
	fake.flushMutex.RLock()
	defer fake.flushMutex.RUnlock()
	return len(fake.flushArgsForCall)
}

func (fake *FakeSender) FlushCalls(stub func() error) {
	fake.flushMutex.Lock()
	defer fake.flushMutex.Unlock()
	fake.FlushStub = stub
}

func (fake *FakeSender) FlushReturns(result1 error) {
	fake.flushMutex.Lock()
	defer fake.flushMutex.Unlock()
	fake.FlushStub = nil
	fake.flushReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) FlushReturnsOnCall(i int, result1 error) {
	fake.flushMutex.Lock()
	defer fake.flushMutex.Unlock()
	fake.FlushStub = nil
	if fake.flushReturnsOnCall == nil {
		fake.flushReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.flushReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) GetFailureCount() int64 {
	fake.getFailureCountMutex.Lock()
	ret, specificReturn := fake.getFailureCountReturnsOnCall[len(fake.getFailureCountArgsForCall)]
	fake.getFailureCountArgsForCall = append(fake.getFailureCountArgsForCall, struct {
	}{})
	fake.recordInvocation("GetFailureCount", []interface{}{})
	fake.getFailureCountMutex.Unlock()
	if fake.GetFailureCountStub != nil {
		return fake.GetFailureCountStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getFailureCountReturns
	return fakeReturns.result1
}

func (fake *FakeSender) GetFailureCountCallCount() int {
	fake.getFailureCountMutex.RLock()
	defer fake.getFailureCountMutex.RUnlock()
	return len(fake.getFailureCountArgsForCall)
}

func (fake *FakeSender) GetFailureCountCalls(stub func() int64) {
	fake.getFailureCountMutex.Lock()
	defer fake.getFailureCountMutex.Unlock()
	fake.GetFailureCountStub = stub
}

func (fake *FakeSender) GetFailureCountReturns(result1 int64) {
	fake.getFailureCountMutex.Lock()
	defer fake.getFailureCountMutex.Unlock()
	fake.GetFailureCountStub = nil
	fake.getFailureCountReturns = struct {
		result1 int64
	}{result1}
}

func (fake *FakeSender) GetFailureCountReturnsOnCall(i int, result1 int64) {
	fake.getFailureCountMutex.Lock()
	defer fake.getFailureCountMutex.Unlock()
	fake.GetFailureCountStub = nil
	if fake.getFailureCountReturnsOnCall == nil {
		fake.getFailureCountReturnsOnCall = make(map[int]struct {
			result1 int64
		})
	}
	fake.getFailureCountReturnsOnCall[i] = struct {
		result1 int64
	}{result1}
}

func (fake *FakeSender) SendDeltaCounter(arg1 string, arg2 float64, arg3 string, arg4 map[string]string) error {
	fake.sendDeltaCounterMutex.Lock()
	ret, specificReturn := fake.sendDeltaCounterReturnsOnCall[len(fake.sendDeltaCounterArgsForCall)]
	fake.sendDeltaCounterArgsForCall = append(fake.sendDeltaCounterArgsForCall, struct {
		arg1 string
		arg2 float64
		arg3 string
		arg4 map[string]string
	}{arg1, arg2, arg3, arg4})
	fake.recordInvocation("SendDeltaCounter", []interface{}{arg1, arg2, arg3, arg4})
	fake.sendDeltaCounterMutex.Unlock()
	if fake.SendDeltaCounterStub != nil {
		return fake.SendDeltaCounterStub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendDeltaCounterReturns
	return fakeReturns.result1
}

func (fake *FakeSender) SendDeltaCounterCallCount() int {
	fake.sendDeltaCounterMutex.RLock()
	defer fake.sendDeltaCounterMutex.RUnlock()
	return len(fake.sendDeltaCounterArgsForCall)
}

func (fake *FakeSender) SendDeltaCounterCalls(stub func(string, float64, string, map[string]string) error) {
	fake.sendDeltaCounterMutex.Lock()
	defer fake.sendDeltaCounterMutex.Unlock()
	fake.SendDeltaCounterStub = stub
}

func (fake *FakeSender) SendDeltaCounterArgsForCall(i int) (string, float64, string, map[string]string) {
	fake.sendDeltaCounterMutex.RLock()
	defer fake.sendDeltaCounterMutex.RUnlock()
	argsForCall := fake.sendDeltaCounterArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeSender) SendDeltaCounterReturns(result1 error) {
	fake.sendDeltaCounterMutex.Lock()
	defer fake.sendDeltaCounterMutex.Unlock()
	fake.SendDeltaCounterStub = nil
	fake.sendDeltaCounterReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) SendDeltaCounterReturnsOnCall(i int, result1 error) {
	fake.sendDeltaCounterMutex.Lock()
	defer fake.sendDeltaCounterMutex.Unlock()
	fake.SendDeltaCounterStub = nil
	if fake.sendDeltaCounterReturnsOnCall == nil {
		fake.sendDeltaCounterReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendDeltaCounterReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) SendDistribution(arg1 string, arg2 []histogram.Centroid, arg3 map[histogram.Granularity]bool, arg4 int64, arg5 string, arg6 map[string]string) error {
	var arg2Copy []histogram.Centroid
	if arg2 != nil {
		arg2Copy = make([]histogram.Centroid, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.sendDistributionMutex.Lock()
	ret, specificReturn := fake.sendDistributionReturnsOnCall[len(fake.sendDistributionArgsForCall)]
	fake.sendDistributionArgsForCall = append(fake.sendDistributionArgsForCall, struct {
		arg1 string
		arg2 []histogram.Centroid
		arg3 map[histogram.Granularity]bool
		arg4 int64
		arg5 string
		arg6 map[string]string
	}{arg1, arg2Copy, arg3, arg4, arg5, arg6})
	fake.recordInvocation("SendDistribution", []interface{}{arg1, arg2Copy, arg3, arg4, arg5, arg6})
	fake.sendDistributionMutex.Unlock()
	if fake.SendDistributionStub != nil {
		return fake.SendDistributionStub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendDistributionReturns
	return fakeReturns.result1
}

func (fake *FakeSender) SendDistributionCallCount() int {
	fake.sendDistributionMutex.RLock()
	defer fake.sendDistributionMutex.RUnlock()
	return len(fake.sendDistributionArgsForCall)
}

func (fake *FakeSender) SendDistributionCalls(stub func(string, []histogram.Centroid, map[histogram.Granularity]bool, int64, string, map[string]string) error) {
	fake.sendDistributionMutex.Lock()
	defer fake.sendDistributionMutex.Unlock()
	fake.SendDistributionStub = stub
}

func (fake *FakeSender) SendDistributionArgsForCall(i int) (string, []histogram.Centroid, map[histogram.Granularity]bool, int64, string, map[string]string) {
	fake.sendDistributionMutex.RLock()
	defer fake.sendDistributionMutex.RUnlock()
	argsForCall := fake.sendDistributionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeSender) SendDistributionReturns(result1 error) {
	fake.sendDistributionMutex.Lock()
	defer fake.sendDistributionMutex.Unlock()
	fake.SendDistributionStub = nil
	fake.sendDistributionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) SendDistributionReturnsOnCall(i int, result1 error) {
	fake.sendDistributionMutex.Lock()
	defer fake.sendDistributionMutex.Unlock()
	fake.SendDistributionStub = nil
	if fake.sendDistributionReturnsOnCall == nil {
		fake.sendDistributionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendDistributionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) SendEvent(arg1 string, arg2 int64, arg3 int64, arg4 string, arg5 map[string]string, arg6 ...event.Option) error {
	fake.sendEventMutex.Lock()
	ret, specificReturn := fake.sendEventReturnsOnCall[len(fake.sendEventArgsForCall)]
	fake.sendEventArgsForCall = append(fake.sendEventArgsForCall, struct {
		arg1 string
		arg2 int64
		arg3 int64
		arg4 string
		arg5 map[string]string
		arg6 []event.Option
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.recordInvocation("SendEvent", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.sendEventMutex.Unlock()
	if fake.SendEventStub != nil {
		return fake.SendEventStub(arg1, arg2, arg3, arg4, arg5, arg6...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendEventReturns
	return fakeReturns.result1
}

func (fake *FakeSender) SendEventCallCount() int {
	fake.sendEventMutex.RLock()
	defer fake.sendEventMutex.RUnlock()
	return len(fake.sendEventArgsForCall)
}

func (fake *FakeSender) SendEventCalls(stub func(string, int64, int64, string, map[string]string, ...event.Option) error) {
	fake.sendEventMutex.Lock()
	defer fake.sendEventMutex.Unlock()
	fake.SendEventStub = stub
}

func (fake *FakeSender) SendEventArgsForCall(i int) (string, int64, int64, string, map[string]string, []event.Option) {
	fake.sendEventMutex.RLock()
	defer fake.sendEventMutex.RUnlock()
	argsForCall := fake.sendEventArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeSender) SendEventReturns(result1 error) {
	fake.sendEventMutex.Lock()
	defer fake.sendEventMutex.Unlock()
	fake.SendEventStub = nil
	fake.sendEventReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) SendEventReturnsOnCall(i int, result1 error) {
	fake.sendEventMutex.Lock()
	defer fake.sendEventMutex.Unlock()
	fake.SendEventStub = nil
	if fake.sendEventReturnsOnCall == nil {
		fake.sendEventReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendEventReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) SendMetric(arg1 string, arg2 float64, arg3 int64, arg4 string, arg5 map[string]string) error {
	fake.sendMetricMutex.Lock()
	ret, specificReturn := fake.sendMetricReturnsOnCall[len(fake.sendMetricArgsForCall)]
	fake.sendMetricArgsForCall = append(fake.sendMetricArgsForCall, struct {
		arg1 string
		arg2 float64
		arg3 int64
		arg4 string
		arg5 map[string]string
	}{arg1, arg2, arg3, arg4, arg5})
	fake.recordInvocation("SendMetric", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.sendMetricMutex.Unlock()
	if fake.SendMetricStub != nil {
		return fake.SendMetricStub(arg1, arg2, arg3, arg4, arg5)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendMetricReturns
	return fakeReturns.result1
}

func (fake *FakeSender) SendMetricCallCount() int {
	fake.sendMetricMutex.RLock()
	defer fake.sendMetricMutex.RUnlock()
	return len(fake.sendMetricArgsForCall)
}

func (fake *FakeSender) SendMetricCalls(stub func(string, float64, int64, string, map[string]string) error) {
	fake.sendMetricMutex.Lock()
	defer fake.sendMetricMutex.Unlock()
	fake.SendMetricStub = stub
}

func (fake *FakeSender) SendMetricArgsForCall(i int) (string, float64, int64, string, map[string]string) {
	fake.sendMetricMutex.RLock()
	defer fake.sendMetricMutex.RUnlock()
	argsForCall := fake.sendMetricArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeSender) SendMetricReturns(result1 error) {
	fake.sendMetricMutex.Lock()
	defer fake.sendMetricMutex.Unlock()
	fake.SendMetricStub = nil
	fake.sendMetricReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) SendMetricReturnsOnCall(i int, result1 error) {
	fake.sendMetricMutex.Lock()
	defer fake.sendMetricMutex.Unlock()
	fake.SendMetricStub = nil
	if fake.sendMetricReturnsOnCall == nil {
		fake.sendMetricReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendMetricReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) SendSpan(arg1 string, arg2 int64, arg3 int64, arg4 string, arg5 string, arg6 string, arg7 []string, arg8 []string, arg9 []senders.SpanTag, arg10 []senders.SpanLog) error {
	var arg7Copy []string
	if arg7 != nil {
		arg7Copy = make([]string, len(arg7))
		copy(arg7Copy, arg7)
	}
	var arg8Copy []string
	if arg8 != nil {
		arg8Copy = make([]string, len(arg8))
		copy(arg8Copy, arg8)
	}
	var arg9Copy []senders.SpanTag
	if arg9 != nil {
		arg9Copy = make([]senders.SpanTag, len(arg9))
		copy(arg9Copy, arg9)
	}
	var arg10Copy []senders.SpanLog
	if arg10 != nil {
		arg10Copy = make([]senders.SpanLog, len(arg10))
		copy(arg10Copy, arg10)
	}
	fake.sendSpanMutex.Lock()
	ret, specificReturn := fake.sendSpanReturnsOnCall[len(fake.sendSpanArgsForCall)]
	fake.sendSpanArgsForCall = append(fake.sendSpanArgsForCall, struct {
		arg1  string
		arg2  int64
		arg3  int64
		arg4  string
		arg5  string
		arg6  string
		arg7  []string
		arg8  []string
		arg9  []senders.SpanTag
		arg10 []senders.SpanLog
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7Copy, arg8Copy, arg9Copy, arg10Copy})
	fake.recordInvocation("SendSpan", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7Copy, arg8Copy, arg9Copy, arg10Copy})
	fake.sendSpanMutex.Unlock()
	if fake.SendSpanStub != nil {
		return fake.SendSpanStub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.sendSpanReturns
	return fakeReturns.result1
}

func (fake *FakeSender) SendSpanCallCount() int {
	fake.sendSpanMutex.RLock()
	defer fake.sendSpanMutex.RUnlock()
	return len(fake.sendSpanArgsForCall)
}

func (fake *FakeSender) SendSpanCalls(stub func(string, int64, int64, string, string, string, []string, []string, []senders.SpanTag, []senders.SpanLog) error) {
	fake.sendSpanMutex.Lock()
	defer fake.sendSpanMutex.Unlock()
	fake.SendSpanStub = stub
}

func (fake *FakeSender) SendSpanArgsForCall(i int) (string, int64, int64, string, string, string, []string, []string, []senders.SpanTag, []senders.SpanLog) {
	fake.sendSpanMutex.RLock()
	defer fake.sendSpanMutex.RUnlock()
	argsForCall := fake.sendSpanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8, argsForCall.arg9, argsForCall.arg10
}

func (fake *FakeSender) SendSpanReturns(result1 error) {
	fake.sendSpanMutex.Lock()
	defer fake.sendSpanMutex.Unlock()
	fake.SendSpanStub = nil
	fake.sendSpanReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) SendSpanReturnsOnCall(i int, result1 error) {
	fake.sendSpanMutex.Lock()
	defer fake.sendSpanMutex.Unlock()
	fake.SendSpanStub = nil
	if fake.sendSpanReturnsOnCall == nil {
		fake.sendSpanReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendSpanReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSender) Start() {
	fake.startMutex.Lock()
	fake.startArgsForCall = append(fake.startArgsForCall, struct {
	}{})
	fake.recordInvocation("Start", []interface{}{})
	fake.startMutex.Unlock()
	if fake.StartStub != nil {
		fake.StartStub()
	}
}

func (fake *FakeSender) StartCallCount() int {
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	return len(fake.startArgsForCall)
}

func (fake *FakeSender) StartCalls(stub func()) {
	fake.startMutex.Lock()
	defer fake.startMutex.Unlock()
	fake.StartStub = stub
}

func (fake *FakeSender) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	fake.flushMutex.RLock()
	defer fake.flushMutex.RUnlock()
	fake.getFailureCountMutex.RLock()
	defer fake.getFailureCountMutex.RUnlock()
	fake.sendDeltaCounterMutex.RLock()
	defer fake.sendDeltaCounterMutex.RUnlock()
	fake.sendDistributionMutex.RLock()
	defer fake.sendDistributionMutex.RUnlock()
	fake.sendEventMutex.RLock()
	defer fake.sendEventMutex.RUnlock()
	fake.sendMetricMutex.RLock()
	defer fake.sendMetricMutex.RUnlock()
	fake.sendSpanMutex.RLock()
	defer fake.sendSpanMutex.RUnlock()
	fake.startMutex.RLock()
	defer fake.startMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSender) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ senders.Sender = new(FakeSender)
